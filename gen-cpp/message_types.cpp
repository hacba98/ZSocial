/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "message_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




Message::~Message() throw() {
}


void Message::__set_msg_id(const int32_t val) {
  this->msg_id = val;
}

void Message::__set_content(const std::string& val) {
  this->content = val;
}

void Message::__set_id_from(const int32_t val) {
  this->id_from = val;
}

void Message::__set_date_create(const int32_t val) {
  this->date_create = val;
}

uint32_t Message::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->msg_id);
          this->__isset.msg_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id_from);
          this->__isset.id_from = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->date_create);
          this->__isset.date_create = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Message::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Message");

  xfer += oprot->writeFieldBegin("msg_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->msg_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id_from", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->id_from);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("date_create", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->date_create);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Message &a, Message &b) {
  using ::std::swap;
  swap(a.msg_id, b.msg_id);
  swap(a.content, b.content);
  swap(a.id_from, b.id_from);
  swap(a.date_create, b.date_create);
  swap(a.__isset, b.__isset);
}

Message::Message(const Message& other0) {
  msg_id = other0.msg_id;
  content = other0.content;
  id_from = other0.id_from;
  date_create = other0.date_create;
  __isset = other0.__isset;
}
Message& Message::operator=(const Message& other1) {
  msg_id = other1.msg_id;
  content = other1.content;
  id_from = other1.id_from;
  date_create = other1.date_create;
  __isset = other1.__isset;
  return *this;
}
void Message::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Message(";
  out << "msg_id=" << to_string(msg_id);
  out << ", " << "content=" << to_string(content);
  out << ", " << "id_from=" << to_string(id_from);
  out << ", " << "date_create=" << to_string(date_create);
  out << ")";
}


ListBox::~ListBox() throw() {
}


void ListBox::__set__id(const int32_t val) {
  this->_id = val;
}

void ListBox::__set_list_inbox(const std::vector<std::string> & val) {
  this->list_inbox = val;
}

void ListBox::__set_count(const int32_t val) {
  this->count = val;
}

uint32_t ListBox::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_id);
          this->__isset._id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->list_inbox.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->list_inbox.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readString(this->list_inbox[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.list_inbox = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListBox::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListBox");

  xfer += oprot->writeFieldBegin("_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("list_inbox", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->list_inbox.size()));
    std::vector<std::string> ::const_iterator _iter7;
    for (_iter7 = this->list_inbox.begin(); _iter7 != this->list_inbox.end(); ++_iter7)
    {
      xfer += oprot->writeString((*_iter7));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListBox &a, ListBox &b) {
  using ::std::swap;
  swap(a._id, b._id);
  swap(a.list_inbox, b.list_inbox);
  swap(a.count, b.count);
  swap(a.__isset, b.__isset);
}

ListBox::ListBox(const ListBox& other8) {
  _id = other8._id;
  list_inbox = other8.list_inbox;
  count = other8.count;
  __isset = other8.__isset;
}
ListBox& ListBox::operator=(const ListBox& other9) {
  _id = other9._id;
  list_inbox = other9.list_inbox;
  count = other9.count;
  __isset = other9.__isset;
  return *this;
}
void ListBox::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListBox(";
  out << "_id=" << to_string(_id);
  out << ", " << "list_inbox=" << to_string(list_inbox);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


IB_Info::~IB_Info() throw() {
}


void IB_Info::__set__id(const std::string& val) {
  this->_id = val;
}

void IB_Info::__set_count(const int32_t val) {
  this->count = val;
}

uint32_t IB_Info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_id);
          this->__isset._id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IB_Info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IB_Info");

  xfer += oprot->writeFieldBegin("_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IB_Info &a, IB_Info &b) {
  using ::std::swap;
  swap(a._id, b._id);
  swap(a.count, b.count);
  swap(a.__isset, b.__isset);
}

IB_Info::IB_Info(const IB_Info& other10) {
  _id = other10._id;
  count = other10.count;
  __isset = other10.__isset;
}
IB_Info& IB_Info::operator=(const IB_Info& other11) {
  _id = other11._id;
  count = other11.count;
  __isset = other11.__isset;
  return *this;
}
void IB_Info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IB_Info(";
  out << "_id=" << to_string(_id);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


Inbox::~Inbox() throw() {
}


void Inbox::__set__id(const std::string& val) {
  this->_id = val;
}

void Inbox::__set__count(const int32_t val) {
  this->_count = val;
}

void Inbox::__set_list_msg(const std::vector<int32_t> & val) {
  this->list_msg = val;
}

uint32_t Inbox::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_id);
          this->__isset._id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_count);
          this->__isset._count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->list_msg.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->list_msg.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += iprot->readI32(this->list_msg[_i16]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.list_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Inbox::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Inbox");

  xfer += oprot->writeFieldBegin("_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("list_msg", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->list_msg.size()));
    std::vector<int32_t> ::const_iterator _iter17;
    for (_iter17 = this->list_msg.begin(); _iter17 != this->list_msg.end(); ++_iter17)
    {
      xfer += oprot->writeI32((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Inbox &a, Inbox &b) {
  using ::std::swap;
  swap(a._id, b._id);
  swap(a._count, b._count);
  swap(a.list_msg, b.list_msg);
  swap(a.__isset, b.__isset);
}

Inbox::Inbox(const Inbox& other18) {
  _id = other18._id;
  _count = other18._count;
  list_msg = other18.list_msg;
  __isset = other18.__isset;
}
Inbox& Inbox::operator=(const Inbox& other19) {
  _id = other19._id;
  _count = other19._count;
  list_msg = other19.list_msg;
  __isset = other19.__isset;
  return *this;
}
void Inbox::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Inbox(";
  out << "_id=" << to_string(_id);
  out << ", " << "_count=" << to_string(_count);
  out << ", " << "list_msg=" << to_string(list_msg);
  out << ")";
}


MessageCreateResult::~MessageCreateResult() throw() {
}


void MessageCreateResult::__set_errorCode(const int32_t val) {
  this->errorCode = val;
}

void MessageCreateResult::__set_message(const std::string& val) {
  this->message = val;
}

void MessageCreateResult::__set_new_count(const int32_t val) {
  this->new_count = val;
}

uint32_t MessageCreateResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->new_count);
          this->__isset.new_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MessageCreateResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MessageCreateResult");

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errorCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->new_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MessageCreateResult &a, MessageCreateResult &b) {
  using ::std::swap;
  swap(a.errorCode, b.errorCode);
  swap(a.message, b.message);
  swap(a.new_count, b.new_count);
  swap(a.__isset, b.__isset);
}

MessageCreateResult::MessageCreateResult(const MessageCreateResult& other20) {
  errorCode = other20.errorCode;
  message = other20.message;
  new_count = other20.new_count;
  __isset = other20.__isset;
}
MessageCreateResult& MessageCreateResult::operator=(const MessageCreateResult& other21) {
  errorCode = other21.errorCode;
  message = other21.message;
  new_count = other21.new_count;
  __isset = other21.__isset;
  return *this;
}
void MessageCreateResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MessageCreateResult(";
  out << "errorCode=" << to_string(errorCode);
  out << ", " << "message=" << to_string(message);
  out << ", " << "new_count=" << to_string(new_count);
  out << ")";
}


ListMessage::~ListMessage() throw() {
}


void ListMessage::__set_count(const int32_t val) {
  this->count = val;
}

void ListMessage::__set_msglist(const std::vector<Message> & val) {
  this->msglist = val;
}

uint32_t ListMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->msglist.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->msglist.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->msglist[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.msglist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListMessage");

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msglist", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->msglist.size()));
    std::vector<Message> ::const_iterator _iter27;
    for (_iter27 = this->msglist.begin(); _iter27 != this->msglist.end(); ++_iter27)
    {
      xfer += (*_iter27).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListMessage &a, ListMessage &b) {
  using ::std::swap;
  swap(a.count, b.count);
  swap(a.msglist, b.msglist);
  swap(a.__isset, b.__isset);
}

ListMessage::ListMessage(const ListMessage& other28) {
  count = other28.count;
  msglist = other28.msglist;
  __isset = other28.__isset;
}
ListMessage& ListMessage::operator=(const ListMessage& other29) {
  count = other29.count;
  msglist = other29.msglist;
  __isset = other29.__isset;
  return *this;
}
void ListMessage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListMessage(";
  out << "count=" << to_string(count);
  out << ", " << "msglist=" << to_string(msglist);
  out << ")";
}


ListMessageResult::~ListMessageResult() throw() {
}


void ListMessageResult::__set_errorCode(const int32_t val) {
  this->errorCode = val;
}

void ListMessageResult::__set_message(const std::string& val) {
  this->message = val;
}

void ListMessageResult::__set_result(const ListMessage& val) {
  this->result = val;
}

uint32_t ListMessageResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListMessageResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListMessageResult");

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errorCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListMessageResult &a, ListMessageResult &b) {
  using ::std::swap;
  swap(a.errorCode, b.errorCode);
  swap(a.message, b.message);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

ListMessageResult::ListMessageResult(const ListMessageResult& other30) {
  errorCode = other30.errorCode;
  message = other30.message;
  result = other30.result;
  __isset = other30.__isset;
}
ListMessageResult& ListMessageResult::operator=(const ListMessageResult& other31) {
  errorCode = other31.errorCode;
  message = other31.message;
  result = other31.result;
  __isset = other31.__isset;
  return *this;
}
void ListMessageResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListMessageResult(";
  out << "errorCode=" << to_string(errorCode);
  out << ", " << "message=" << to_string(message);
  out << ", " << "result=" << to_string(result);
  out << ")";
}


KeyMsgResult::~KeyMsgResult() throw() {
}


void KeyMsgResult::__set_errorCode(const int32_t val) {
  this->errorCode = val;
}

void KeyMsgResult::__set_message(const std::string& val) {
  this->message = val;
}

void KeyMsgResult::__set_key(const std::string& val) {
  this->key = val;
}

uint32_t KeyMsgResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KeyMsgResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KeyMsgResult");

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errorCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyMsgResult &a, KeyMsgResult &b) {
  using ::std::swap;
  swap(a.errorCode, b.errorCode);
  swap(a.message, b.message);
  swap(a.key, b.key);
  swap(a.__isset, b.__isset);
}

KeyMsgResult::KeyMsgResult(const KeyMsgResult& other32) {
  errorCode = other32.errorCode;
  message = other32.message;
  key = other32.key;
  __isset = other32.__isset;
}
KeyMsgResult& KeyMsgResult::operator=(const KeyMsgResult& other33) {
  errorCode = other33.errorCode;
  message = other33.message;
  key = other33.key;
  __isset = other33.__isset;
  return *this;
}
void KeyMsgResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KeyMsgResult(";
  out << "errorCode=" << to_string(errorCode);
  out << ", " << "message=" << to_string(message);
  out << ", " << "key=" << to_string(key);
  out << ")";
}


